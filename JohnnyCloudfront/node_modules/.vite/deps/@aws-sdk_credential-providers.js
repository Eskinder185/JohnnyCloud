import {
  CredentialsProviderError,
  FetchHttpHandler,
  normalizeProvider,
  parseRfc3339DateTime,
  sdkStreamMixin
} from "./chunk-Y7RYPMHW.js";
import {
  HttpRequest
} from "./chunk-Z3KL66RP.js";
import {
  __publicField
} from "./chunk-2GTGKKMZ.js";

// node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/resolveLogins.js
function resolveLogins(logins) {
  return Promise.all(Object.keys(logins).reduce((arr, name) => {
    const tokenOrProvider = logins[name];
    if (typeof tokenOrProvider === "string") {
      arr.push([name, tokenOrProvider]);
    } else {
      arr.push(tokenOrProvider().then((token) => [name, token]));
    }
    return arr;
  }, [])).then((resolvedPairs) => resolvedPairs.reduce((logins2, [key, value]) => {
    logins2[key] = value;
    return logins2;
  }, {}));
}

// node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentity.js
function fromCognitoIdentity(parameters) {
  return async (awsIdentityProperties) => {
    var _a;
    (_a = parameters.logger) == null ? void 0 : _a.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
    const { GetCredentialsForIdentityCommand, CognitoIdentityClient } = await import("./loadCognitoIdentity-E7HYXAGC.js");
    const fromConfigs = (property) => {
      var _a2, _b, _c;
      return ((_a2 = parameters.clientConfig) == null ? void 0 : _a2[property]) ?? ((_b = parameters.parentClientConfig) == null ? void 0 : _b[property]) ?? ((_c = awsIdentityProperties == null ? void 0 : awsIdentityProperties.callerClientConfig) == null ? void 0 : _c[property]);
    };
    const { Credentials: { AccessKeyId = throwOnMissingAccessKeyId(parameters.logger), Expiration, SecretKey = throwOnMissingSecretKey(parameters.logger), SessionToken } = throwOnMissingCredentials(parameters.logger) } = await (parameters.client ?? new CognitoIdentityClient(Object.assign({}, parameters.clientConfig ?? {}, {
      region: fromConfigs("region"),
      profile: fromConfigs("profile")
    }))).send(new GetCredentialsForIdentityCommand({
      CustomRoleArn: parameters.customRoleArn,
      IdentityId: parameters.identityId,
      Logins: parameters.logins ? await resolveLogins(parameters.logins) : void 0
    }));
    return {
      identityId: parameters.identityId,
      accessKeyId: AccessKeyId,
      secretAccessKey: SecretKey,
      sessionToken: SessionToken,
      expiration: Expiration
    };
  };
}
function throwOnMissingAccessKeyId(logger) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID", { logger });
}
function throwOnMissingCredentials(logger) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials", { logger });
}
function throwOnMissingSecretKey(logger) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key", { logger });
}

// node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/IndexedDbStorage.js
var STORE_NAME = "IdentityIds";
var IndexedDbStorage = class {
  constructor(dbName = "aws:cognito-identity-ids") {
    __publicField(this, "dbName");
    this.dbName = dbName;
  }
  getItem(key) {
    return this.withObjectStore("readonly", (store) => {
      const req = store.get(key);
      return new Promise((resolve) => {
        req.onerror = () => resolve(null);
        req.onsuccess = () => resolve(req.result ? req.result.value : null);
      });
    }).catch(() => null);
  }
  removeItem(key) {
    return this.withObjectStore("readwrite", (store) => {
      const req = store.delete(key);
      return new Promise((resolve, reject) => {
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve();
      });
    });
  }
  setItem(id, value) {
    return this.withObjectStore("readwrite", (store) => {
      const req = store.put({ id, value });
      return new Promise((resolve, reject) => {
        req.onerror = () => reject(req.error);
        req.onsuccess = () => resolve();
      });
    });
  }
  getDb() {
    const openDbRequest = self.indexedDB.open(this.dbName, 1);
    return new Promise((resolve, reject) => {
      openDbRequest.onsuccess = () => {
        resolve(openDbRequest.result);
      };
      openDbRequest.onerror = () => {
        reject(openDbRequest.error);
      };
      openDbRequest.onblocked = () => {
        reject(new Error("Unable to access DB"));
      };
      openDbRequest.onupgradeneeded = () => {
        const db = openDbRequest.result;
        db.onerror = () => {
          reject(new Error("Failed to create object store"));
        };
        db.createObjectStore(STORE_NAME, { keyPath: "id" });
      };
    });
  }
  withObjectStore(mode, action) {
    return this.getDb().then((db) => {
      const tx = db.transaction(STORE_NAME, mode);
      tx.oncomplete = () => db.close();
      return new Promise((resolve, reject) => {
        tx.onerror = () => reject(tx.error);
        resolve(action(tx.objectStore(STORE_NAME)));
      }).catch((err) => {
        db.close();
        throw err;
      });
    });
  }
};

// node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/InMemoryStorage.js
var InMemoryStorage = class {
  constructor(store = {}) {
    __publicField(this, "store");
    this.store = store;
  }
  getItem(key) {
    if (key in this.store) {
      return this.store[key];
    }
    return null;
  }
  removeItem(key) {
    delete this.store[key];
  }
  setItem(key, value) {
    this.store[key] = value;
  }
};

// node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/localStorage.js
var inMemoryStorage = new InMemoryStorage();
function localStorage() {
  if (typeof self === "object" && self.indexedDB) {
    return new IndexedDbStorage();
  }
  if (typeof window === "object" && window.localStorage) {
    return window.localStorage;
  }
  return inMemoryStorage;
}

// node_modules/@aws-sdk/credential-provider-cognito-identity/dist-es/fromCognitoIdentityPool.js
function fromCognitoIdentityPool({ accountId, cache = localStorage(), client, clientConfig, customRoleArn, identityPoolId, logins, userIdentifier = !logins || Object.keys(logins).length === 0 ? "ANONYMOUS" : void 0, logger, parentClientConfig }) {
  logger == null ? void 0 : logger.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
  const cacheKey = userIdentifier ? `aws:cognito-identity-credentials:${identityPoolId}:${userIdentifier}` : void 0;
  let provider = async (awsIdentityProperties) => {
    const { GetIdCommand, CognitoIdentityClient } = await import("./loadCognitoIdentity-E7HYXAGC.js");
    const fromConfigs = (property) => {
      var _a;
      return (clientConfig == null ? void 0 : clientConfig[property]) ?? (parentClientConfig == null ? void 0 : parentClientConfig[property]) ?? ((_a = awsIdentityProperties == null ? void 0 : awsIdentityProperties.callerClientConfig) == null ? void 0 : _a[property]);
    };
    const _client = client ?? new CognitoIdentityClient(Object.assign({}, clientConfig ?? {}, {
      region: fromConfigs("region"),
      profile: fromConfigs("profile")
    }));
    let identityId = cacheKey && await cache.getItem(cacheKey);
    if (!identityId) {
      const { IdentityId = throwOnMissingId(logger) } = await _client.send(new GetIdCommand({
        AccountId: accountId,
        IdentityPoolId: identityPoolId,
        Logins: logins ? await resolveLogins(logins) : void 0
      }));
      identityId = IdentityId;
      if (cacheKey) {
        Promise.resolve(cache.setItem(cacheKey, identityId)).catch(() => {
        });
      }
    }
    provider = fromCognitoIdentity({
      client: _client,
      customRoleArn,
      logins,
      identityId
    });
    return provider(awsIdentityProperties);
  };
  return (awsIdentityProperties) => provider(awsIdentityProperties).catch(async (err) => {
    if (cacheKey) {
      Promise.resolve(cache.removeItem(cacheKey)).catch(() => {
      });
    }
    throw err;
  });
}
function throwOnMissingId(logger) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID", { logger });
}

// node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentity.js
var fromCognitoIdentity2 = (options) => fromCognitoIdentity({
  ...options
});

// node_modules/@aws-sdk/credential-providers/dist-es/fromCognitoIdentityPool.js
var fromCognitoIdentityPool2 = (options) => fromCognitoIdentityPool({
  ...options
});

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/checkUrl.js
var ECS_CONTAINER_HOST = "169.254.170.2";
var EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
var EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
var checkUrl = (url, logger) => {
  if (url.protocol === "https:") {
    return;
  }
  if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
    return;
  }
  if (url.hostname.includes("[")) {
    if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
      return;
    }
  } else {
    if (url.hostname === "localhost") {
      return;
    }
    const ipComponents = url.hostname.split(".");
    const inRange = (component) => {
      const num = parseInt(component, 10);
      return 0 <= num && num <= 255;
    };
    if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
      return;
    }
  }
  throw new CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger });
};

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/requestHelpers.js
function createGetRequest(url) {
  return new HttpRequest({
    protocol: url.protocol,
    hostname: url.hostname,
    port: Number(url.port),
    path: url.pathname,
    query: Array.from(url.searchParams.entries()).reduce((acc, [k, v]) => {
      acc[k] = v;
      return acc;
    }, {}),
    fragment: url.hash
  });
}
async function getCredentials(response, logger) {
  const stream = sdkStreamMixin(response.body);
  const str = await stream.transformToString();
  if (response.statusCode === 200) {
    const parsed = JSON.parse(str);
    if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
      throw new CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger });
    }
    return {
      accessKeyId: parsed.AccessKeyId,
      secretAccessKey: parsed.SecretAccessKey,
      sessionToken: parsed.Token,
      expiration: parseRfc3339DateTime(parsed.Expiration)
    };
  }
  if (response.statusCode >= 400 && response.statusCode < 500) {
    let parsedBody = {};
    try {
      parsedBody = JSON.parse(str);
    } catch (e) {
    }
    throw Object.assign(new CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger }), {
      Code: parsedBody.Code,
      Message: parsedBody.Message
    });
  }
  throw new CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger });
}

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/retry-wrapper.js
var retryWrapper = (toRetry, maxRetries, delayMs) => {
  return async () => {
    for (let i = 0; i < maxRetries; ++i) {
      try {
        return await toRetry();
      } catch (e) {
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }
    return await toRetry();
  };
};

// node_modules/@aws-sdk/credential-provider-http/dist-es/fromHttp/fromHttp.browser.js
var fromHttp = (options = {}) => {
  var _a;
  (_a = options.logger) == null ? void 0 : _a.debug("@aws-sdk/credential-provider-http - fromHttp");
  let host;
  const full = options.credentialsFullUri;
  if (full) {
    host = full;
  } else {
    throw new CredentialsProviderError("No HTTP credential provider host provided.", { logger: options.logger });
  }
  const url = new URL(host);
  checkUrl(url, options.logger);
  const requestHandler = new FetchHttpHandler();
  return retryWrapper(async () => {
    const request = createGetRequest(url);
    if (options.authorizationToken) {
      request.headers.Authorization = options.authorizationToken;
    }
    const result = await requestHandler.handle(request);
    return getCredentials(result.response);
  }, options.maxRetries ?? 3, options.timeout ?? 1e3);
};

// node_modules/@aws-sdk/credential-providers/dist-es/fromTemporaryCredentials.base.js
var ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
var fromTemporaryCredentials = (options, credentialDefaultProvider, regionProvider) => {
  let stsClient;
  return async (awsIdentityProperties = {}) => {
    var _a, _b, _c, _d, _e, _f;
    const { callerClientConfig } = awsIdentityProperties;
    const profile = ((_a = options.clientConfig) == null ? void 0 : _a.profile) ?? (callerClientConfig == null ? void 0 : callerClientConfig.profile);
    const logger = options.logger ?? (callerClientConfig == null ? void 0 : callerClientConfig.logger);
    logger == null ? void 0 : logger.debug("@aws-sdk/credential-providers - fromTemporaryCredentials (STS)");
    const params = { ...options.params, RoleSessionName: options.params.RoleSessionName ?? "aws-sdk-js-" + Date.now() };
    if (params == null ? void 0 : params.SerialNumber) {
      if (!options.mfaCodeProvider) {
        throw new CredentialsProviderError(`Temporary credential requires multi-factor authentication, but no MFA code callback was provided.`, {
          tryNextLink: false,
          logger
        });
      }
      params.TokenCode = await options.mfaCodeProvider(params == null ? void 0 : params.SerialNumber);
    }
    const { AssumeRoleCommand, STSClient } = await import("./loadSts-C64GHJEU.js");
    if (!stsClient) {
      const defaultCredentialsOrError = typeof credentialDefaultProvider === "function" ? credentialDefaultProvider() : void 0;
      const credentialSources = [
        options.masterCredentials,
        (_b = options.clientConfig) == null ? void 0 : _b.credentials,
        void (callerClientConfig == null ? void 0 : callerClientConfig.credentials),
        (_c = callerClientConfig == null ? void 0 : callerClientConfig.credentialDefaultProvider) == null ? void 0 : _c.call(callerClientConfig),
        defaultCredentialsOrError
      ];
      let credentialSource = "STS client default credentials";
      if (credentialSources[0]) {
        credentialSource = "options.masterCredentials";
      } else if (credentialSources[1]) {
        credentialSource = "options.clientConfig.credentials";
      } else if (credentialSources[2]) {
        credentialSource = "caller client's credentials";
        throw new Error("fromTemporaryCredentials recursion in callerClientConfig.credentials");
      } else if (credentialSources[3]) {
        credentialSource = "caller client's credentialDefaultProvider";
      } else if (credentialSources[4]) {
        credentialSource = "AWS SDK default credentials";
      }
      const regionSources = [
        (_d = options.clientConfig) == null ? void 0 : _d.region,
        callerClientConfig == null ? void 0 : callerClientConfig.region,
        await (regionProvider == null ? void 0 : regionProvider({
          profile
        })),
        ASSUME_ROLE_DEFAULT_REGION
      ];
      let regionSource = "default partition's default region";
      if (regionSources[0]) {
        regionSource = "options.clientConfig.region";
      } else if (regionSources[1]) {
        regionSource = "caller client's region";
      } else if (regionSources[2]) {
        regionSource = "file or env region";
      }
      const requestHandlerSources = [
        filterRequestHandler((_e = options.clientConfig) == null ? void 0 : _e.requestHandler),
        filterRequestHandler(callerClientConfig == null ? void 0 : callerClientConfig.requestHandler)
      ];
      let requestHandlerSource = "STS default requestHandler";
      if (requestHandlerSources[0]) {
        requestHandlerSource = "options.clientConfig.requestHandler";
      } else if (requestHandlerSources[1]) {
        requestHandlerSource = "caller client's requestHandler";
      }
      (_f = logger == null ? void 0 : logger.debug) == null ? void 0 : _f.call(logger, `@aws-sdk/credential-providers - fromTemporaryCredentials STS client init with ${regionSource}=${await normalizeProvider(coalesce(regionSources))()}, ${credentialSource}, ${requestHandlerSource}.`);
      stsClient = new STSClient({
        ...options.clientConfig,
        credentials: coalesce(credentialSources),
        logger,
        profile,
        region: coalesce(regionSources),
        requestHandler: coalesce(requestHandlerSources)
      });
    }
    if (options.clientPlugins) {
      for (const plugin of options.clientPlugins) {
        stsClient.middlewareStack.use(plugin);
      }
    }
    const { Credentials } = await stsClient.send(new AssumeRoleCommand(params));
    if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
      throw new CredentialsProviderError(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`, {
        logger
      });
    }
    return {
      accessKeyId: Credentials.AccessKeyId,
      secretAccessKey: Credentials.SecretAccessKey,
      sessionToken: Credentials.SessionToken,
      expiration: Credentials.Expiration,
      credentialScope: Credentials.CredentialScope
    };
  };
};
var filterRequestHandler = (requestHandler) => {
  var _a;
  return ((_a = requestHandler == null ? void 0 : requestHandler.metadata) == null ? void 0 : _a.handlerProtocol) === "h2" ? void 0 : requestHandler;
};
var coalesce = (args) => {
  for (const item of args) {
    if (item !== void 0) {
      return item;
    }
  }
};

// node_modules/@aws-sdk/credential-provider-web-identity/dist-es/fromWebToken.js
var fromWebToken = (init) => async (awsIdentityProperties) => {
  var _a;
  (_a = init.logger) == null ? void 0 : _a.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
  const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
  let { roleAssumerWithWebIdentity } = init;
  if (!roleAssumerWithWebIdentity) {
    const { getDefaultRoleAssumerWithWebIdentity } = await import("./sts-XPW6JSQZ.js");
    roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity({
      ...init.clientConfig,
      credentialProviderLogger: init.logger,
      parentClientConfig: {
        ...awsIdentityProperties == null ? void 0 : awsIdentityProperties.callerClientConfig,
        ...init.parentClientConfig
      }
    }, init.clientPlugins);
  }
  return roleAssumerWithWebIdentity({
    RoleArn: roleArn,
    RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
    WebIdentityToken: webIdentityToken,
    ProviderId: providerId,
    PolicyArns: policyArns,
    Policy: policy,
    DurationSeconds: durationSeconds
  });
};

// node_modules/@aws-sdk/credential-providers/dist-es/fromWebToken.js
var fromWebToken2 = (init) => fromWebToken({
  ...init
});
export {
  fromCognitoIdentity2 as fromCognitoIdentity,
  fromCognitoIdentityPool2 as fromCognitoIdentityPool,
  fromHttp,
  fromTemporaryCredentials,
  fromWebToken2 as fromWebToken
};
//# sourceMappingURL=@aws-sdk_credential-providers.js.map
